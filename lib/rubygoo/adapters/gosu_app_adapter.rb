include Gosu
module Rubygoo

enum = 0
MOUSE_LEFT = enum += 1
MOUSE_MIDDLE = enum += 1
MOUSE_RIGHT = enum += 1
MOUSE_LMASK = enum += 1
MOUSE_MMASK = enum += 1
MOUSE_RMASK = enum += 1

K_UNKNOWN = enum += 1
K_FIRST = enum += 1
K_BACKSPACE = KbBackspace
K_TAB = KbTab
K_CLEAR = enum += 1
K_RETURN = KbReturn
K_PAUSE = enum += 1
K_ESCAPE = KbEscape
K_SPACE = KbSpace
K_EXCLAIM = enum += 1
K_QUOTEDBL = enum += 1
K_HASH = enum += 1
K_DOLLAR = enum += 1
K_AMPERSAND = enum += 1
K_QUOTE = enum += 1
K_LEFTPAREN = enum += 1
K_RIGHTPAREN = enum += 1
K_ASTERISK = enum += 1
K_PLUS = enum += 1
K_COMMA = enum += 1
K_MINUS = enum += 1
K_PERIOD = enum += 1
K_SLASH = enum += 1
K_0 = Kb0
K_1 = Kb1
K_2 = Kb2
K_3 = Kb3
K_4 = Kb4
K_5 = Kb5
K_6 = Kb6
K_7 = Kb7
K_8 = Kb8
K_9 = Kb9
K_COLON = enum += 1
K_SEMICOLON = enum += 1
K_LESS = enum += 1
K_EQUALS = enum += 1
K_GREATER = enum += 1
K_QUESTION = enum += 1
K_AT = enum += 1
K_LEFTBRACKET = enum += 1
K_BACKSLASH = enum += 1
K_RIGHTBRACKET = enum += 1
K_CARET = enum += 1
K_UNDERSCORE = enum += 1
K_BACKQUOTE = enum += 1
K_A = KbA
K_B = KbB 
K_C = KbC 
K_D = KbD 
K_E = KbE 
K_F = KbF 
K_G = KbG 
K_H = KbH 
K_I = KbI 
K_J = KbJ 
K_K = KbK 
K_L = KbL 
K_M = KbM 
K_N = KbN 
K_O = KbO 
K_P = KbP 
K_Q = KbQ 
K_R = KbR 
K_S = KbS 
K_T = KbT 
K_U = KbU 
K_V = KbV 
K_W = KbW 
K_X = KbX 
K_Y = KbY 
K_Z = KbZ 
K_DELETE = KbDelete

K_WORLD_0 = enum += 1
K_WORLD_1 = enum += 1
K_WORLD_2 = enum += 1
K_WORLD_3 = enum += 1
K_WORLD_4 = enum += 1
K_WORLD_5 = enum += 1
K_WORLD_6 = enum += 1
K_WORLD_7 = enum += 1
K_WORLD_8 = enum += 1
K_WORLD_9 = enum += 1
K_WORLD_10 = enum += 1
K_WORLD_11 = enum += 1
K_WORLD_12 = enum += 1
K_WORLD_13 = enum += 1
K_WORLD_14 = enum += 1
K_WORLD_15 = enum += 1
K_WORLD_16 = enum += 1
K_WORLD_17 = enum += 1
K_WORLD_18 = enum += 1
K_WORLD_19 = enum += 1
K_WORLD_20 = enum += 1
K_WORLD_21 = enum += 1
K_WORLD_22 = enum += 1
K_WORLD_23 = enum += 1
K_WORLD_24 = enum += 1
K_WORLD_25 = enum += 1
K_WORLD_26 = enum += 1
K_WORLD_27 = enum += 1
K_WORLD_28 = enum += 1
K_WORLD_29 = enum += 1
K_WORLD_30 = enum += 1
K_WORLD_31 = enum += 1
K_WORLD_32 = enum += 1
K_WORLD_33 = enum += 1
K_WORLD_34 = enum += 1
K_WORLD_35 = enum += 1
K_WORLD_36 = enum += 1
K_WORLD_37 = enum += 1
K_WORLD_38 = enum += 1
K_WORLD_39 = enum += 1
K_WORLD_40 = enum += 1
K_WORLD_41 = enum += 1
K_WORLD_42 = enum += 1
K_WORLD_43 = enum += 1
K_WORLD_44 = enum += 1
K_WORLD_45 = enum += 1
K_WORLD_46 = enum += 1
K_WORLD_47 = enum += 1
K_WORLD_48 = enum += 1
K_WORLD_49 = enum += 1
K_WORLD_50 = enum += 1
K_WORLD_51 = enum += 1
K_WORLD_52 = enum += 1
K_WORLD_53 = enum += 1
K_WORLD_54 = enum += 1
K_WORLD_55 = enum += 1
K_WORLD_56 = enum += 1
K_WORLD_57 = enum += 1
K_WORLD_58 = enum += 1
K_WORLD_59 = enum += 1
K_WORLD_60 = enum += 1
K_WORLD_61 = enum += 1
K_WORLD_62 = enum += 1
K_WORLD_63 = enum += 1
K_WORLD_64 = enum += 1
K_WORLD_65 = enum += 1
K_WORLD_66 = enum += 1
K_WORLD_67 = enum += 1
K_WORLD_68 = enum += 1
K_WORLD_69 = enum += 1
K_WORLD_70 = enum += 1
K_WORLD_71 = enum += 1
K_WORLD_72 = enum += 1
K_WORLD_73 = enum += 1
K_WORLD_74 = enum += 1
K_WORLD_75 = enum += 1
K_WORLD_76 = enum += 1
K_WORLD_77 = enum += 1
K_WORLD_78 = enum += 1
K_WORLD_79 = enum += 1
K_WORLD_80 = enum += 1
K_WORLD_81 = enum += 1
K_WORLD_82 = enum += 1
K_WORLD_83 = enum += 1
K_WORLD_84 = enum += 1
K_WORLD_85 = enum += 1
K_WORLD_86 = enum += 1
K_WORLD_87 = enum += 1
K_WORLD_88 = enum += 1
K_WORLD_89 = enum += 1
K_WORLD_90 = enum += 1
K_WORLD_91 = enum += 1
K_WORLD_92 = enum += 1
K_WORLD_93 = enum += 1
K_WORLD_94 = enum += 1
K_WORLD_95 = enum += 1

K_KP0 = enum += 1
K_KP1 = enum += 1
K_KP2 = enum += 1
K_KP3 = enum += 1
K_KP4 = enum += 1
K_KP5 = enum += 1
K_KP6 = enum += 1
K_KP7 = enum += 1
K_KP8 = enum += 1
K_KP9 = enum += 1
K_KP_PERIOD = enum += 1
K_KP_DIVIDE = enum += 1
K_KP_MULTIPLY = enum += 1
K_KP_MINUS = enum += 1
K_KP_PLUS = enum += 1
K_KP_ENTER = enum += 1
K_KP_EQUALS = enum += 1

K_UP = KbUp
K_DOWN = KbDown
K_RIGHT = KbRight
K_LEFT = KbLeft
K_INSERT = enum += 1
K_HOME = enum += 1
K_END = enum += 1
K_PAGEUP = enum += 1
K_PAGEDOWN = enum += 1

K_F1 = enum += 1
K_F2 = enum += 1
K_F3 = enum += 1
K_F4 = enum += 1
K_F5 = enum += 1
K_F6 = enum += 1
K_F7 = enum += 1
K_F8 = enum += 1
K_F9 = enum += 1
K_F10 = enum += 1
K_F11 = enum += 1
K_F12 = enum += 1
K_F13 = enum += 1
K_F14 = enum += 1
K_F15 = enum += 1

K_NUMLOCK = enum += 1
K_CAPSLOCK = enum += 1
K_SCROLLOCK = enum += 1
K_RSHIFT = enum += 1
K_LSHIFT = enum += 1
K_RCTRL = enum += 1
K_LCTRL = enum += 1
K_RALT = enum += 1
K_LALT = enum += 1
K_RMETA = enum += 1
K_LMETA = enum += 1
K_LSUPER = enum += 1
K_RSUPER = enum += 1
K_MODE = enum += 1
	
K_HELP = enum += 1
K_PRINT = enum += 1
K_SYSREQ = enum += 1
K_BREAK = enum += 1
K_MENU = enum += 1
K_POWER = enum += 1
K_EURO = enum += 1
K_LAST = enum += 1

K_MOD_NONE = enum += 1
K_MOD_LSHIFT = enum += 1
K_MOD_RSHIFT = enum += 1
K_MOD_LCTRL = enum += 1
K_MOD_RCTRL = enum += 1
K_MOD_LALT = enum += 1
K_MOD_RALT = enum += 1
K_MOD_LMETA = enum += 1
K_MOD_RMETA = enum += 1
K_MOD_NUM = enum += 1
K_MOD_CAPS = enum += 1
K_MOD_MODE = enum += 1
K_MOD_RESERVED = enum += 1

K_MOD_CTRL = enum += 1
K_MOD_SHIFT = enum += 1
K_MOD_ALT = enum += 1
K_MOD_META = enum += 1


# key/mouse event mappings
# Hash to translate mouse button sym to string
MOUSE2STR = {
  MOUSE_LEFT => "left",
  MOUSE_MIDDLE => "middle",
  MOUSE_RIGHT => "right"
}
# And to translate the other way...
STR2MOUSE = MOUSE2STR.invert()
# And allow numbers too (1 = left, so on)...
STR2MOUSE[1] = MOUSE_LEFT
STR2MOUSE[2] = MOUSE_MIDDLE
STR2MOUSE[3] = MOUSE_RIGHT

# All the keys which have ASCII print values
# It is 87 lines from here to the closing }, if you want to skip it...
KEY2ASCII = {
  K_BACKSPACE => "\b",
  K_TAB => "\t",
  K_RETURN => "\n", #SDL docs: "\r". Win vs *nix? What about Mac?
  K_ESCAPE => "^[",
  K_SPACE => " ",
  K_EXCLAIM => "!",
  K_QUOTEDBL => "\"",
  K_HASH => "#",
  K_DOLLAR => "$",
  K_AMPERSAND => "&",
  K_QUOTE => "\'",
  K_LEFTPAREN => "(",
  K_RIGHTPAREN => ")",
  K_ASTERISK => "*",
  K_PLUS => "+",
  K_COMMA => ",",
  K_MINUS => "-",
  K_PERIOD => ".",
  K_SLASH => "/",
  K_0 => "0",
  K_1 => "1",
  K_2 => "2",
  K_3 => "3",
  K_4 => "4",
  K_5 => "5",
  K_6 => "6",
  K_7 => "7",
  K_8 => "8",
  K_9 => "9",
  K_COLON => ":",
  K_SEMICOLON => ";",
  K_LESS => "<",
  K_EQUALS => "=",
  K_GREATER => ">",
  K_QUESTION => "?",
  K_AT => "@",
  K_LEFTBRACKET => "[",
  K_BACKSLASH => "\\",
  K_RIGHTBRACKET => "]",
  K_CARET => "^",
  K_UNDERSCORE => "_",
  K_BACKQUOTE => "`",
  K_A => "a",
  K_B => "b",
  K_C => "c",
  K_D => "d",
  K_E => "e",
  K_F => "f",
  K_G => "g",
  K_H => "h",
  K_I => "i",
  K_J => "j",
  K_K => "k",
  K_L => "l",
  K_M => "m",
  K_N => "n",
  K_O => "o",
  K_P => "p",
  K_Q => "q",
  K_R => "r",
  K_S => "s",
  K_T => "t",
  K_U => "u",
  K_V => "v",
  K_W => "w",
  K_X => "x",
  K_Y => "y",
  K_Z => "z",
  K_KP0 => "0",
  K_KP1 => "1",
  K_KP2 => "2",
  K_KP3 => "3",
  K_KP4 => "4",
  K_KP5 => "5",
  K_KP6 => "6",
  K_KP7 => "7",
  K_KP8 => "8",
  K_KP9 => "9",
  K_KP_PERIOD => ".",
  K_KP_DIVIDE => "/",
  K_KP_MULTIPLY => "*",
  K_KP_MINUS => "-",
  K_KP_PLUS => "+",
  K_KP_ENTER => "\n", #again, SDL docs say "\r"
  K_KP_EQUALS => "=",
}

# And to translate the other way...
ASCII2KEY = KEY2ASCII.invert()
# accept uppercase letters too, return same as lowercase version:
("a".."z").each{ |letter| ASCII2KEY[letter.upcase] = ASCII2KEY[letter] }

# All the keys that are affected by the Shift key, in lower case
# 49 lines from here to the end of the hash
KEY2LOWER = {
  K_QUOTE => "\'",
  K_COMMA => ",",
  K_MINUS => "-",
  K_PERIOD => ".",
  K_SLASH => "/",
  K_0 => "0",
  K_1 => "1",
  K_2 => "2",
  K_3 => "3",
  K_4 => "4",
  K_5 => "5",
  K_6 => "6",
  K_7 => "7",
  K_8 => "8",
  K_9 => "9",
  K_SEMICOLON => ";",
  K_EQUALS => "=",
  K_LEFTBRACKET => "[",
  K_BACKSLASH => "\\",
  K_RIGHTBRACKET => "]",
  K_BACKQUOTE => "`",
  K_A => "a",
  K_B => "b",
  K_C => "c",
  K_D => "d",
  K_E => "e",
  K_F => "f",
  K_G => "g",
  K_H => "h",
  K_I => "i",
  K_J => "j",
  K_K => "k",
  K_L => "l",
  K_M => "m",
  K_N => "n",
  K_O => "o",
  K_P => "p",
  K_Q => "q",
  K_R => "r",
  K_S => "s",
  K_T => "t",
  K_U => "u",
  K_V => "v",
  K_W => "w",
  K_X => "x",
  K_Y => "y",
  K_Z => "z",
}

# All the keys that are affected by the Shift key, in UPPER case
# 49 lines from here to the end of the hash
KEY2UPPER = {
  K_QUOTE => "\"",
  K_COMMA => "<",
  K_MINUS => "_",
  K_PERIOD => ">",
  K_SLASH => "?",
  K_0 => ")",
  K_1 => "!",
  K_2 => "@",
  K_3 => "#",
  K_4 => "$",
  K_5 => "%",
  K_6 => "^",
  K_7 => "&",
  K_8 => "*",
  K_9 => "(",
  K_SEMICOLON => ":",
  K_EQUALS => "+",
  K_LEFTBRACKET => "{",
  K_BACKSLASH => "|",
  K_RIGHTBRACKET => "}",
  K_BACKQUOTE => "~",
  K_A => "A",
  K_B => "B",
  K_C => "C",
  K_D => "D",
  K_E => "E",
  K_F => "F",
  K_G => "G",
  K_H => "H",
  K_I => "I",
  K_J => "J",
  K_K => "K",
  K_L => "L",
  K_M => "M",
  K_N => "N",
  K_O => "O",
  K_P => "P",
  K_Q => "Q",
  K_R => "R",
  K_S => "S",
  K_T => "T",
  K_U => "U",
  K_V => "V",
  K_W => "W",
  K_X => "X",
  K_Y => "Y",
  K_Z => "Z",
}

class GosuAppAdapter

  def initialize(app,main_window)
    @app = app
    @main_window = main_window

    @last_mouse_x = 0
    @last_mouse_y = 0
  end

  def update(time)
    x = @main_window.mouse_x
    y = @main_window.mouse_y
    if x != @last_mouse_x or y != @last_mouse_y
      @app.on_event GooEvent.new(:mouse_motion, { 
        :x => x, :y => y})
    end
    @app.update time
  end

  def draw(target)
    @app.draw target
  end

  # TODO convert keys?!?
  def button_down(id)
    case id
    when MsLeft
      @app.on_event GooEvent.new(:mouse_down, { 
        :x => @main_window.mouse_x, :y => @main_window.mouse_y, 
        :button => MOUSE_LEFT})
    else
      # assume it's a key
      # where do I get the mods? ie shift,alt,ctrl
      # where do I get the string rep of the char?
      mods = []
      mods << K_LALT if @main_window.button_down? KbLeftAlt
      mods << K_RALT if @main_window.button_down? KbRightAlt
      mods << K_LCTRL if @main_window.button_down? KbLeftControl
      mods << K_RCTRL if @main_window.button_down? KbRightControl
      left_shift = @main_window.button_down? KbLeftShift
      right_shift = @main_window.button_down? KbRightShift
      mods << K_LSHIFT if right_shift
      mods << K_RSHIFT if right_shift

      button_string = @main_window.button_id_to_char(id)
      button_string ||= "?"

      button_string.upcase! if left_shift or right_shift

      @app.on_event GooEvent.new(:key_pressed, { 
        :key => id, :mods => mods, :string => button_string})
    end
  end

  def button_up(id)
    case id
    when MsLeft
      @app.on_event GooEvent.new(:mouse_up, { 
        :x => @main_window.mouse_x, :y => @main_window.mouse_y, 
        :button => MOUSE_LEFT})
    end
  end
end

end
